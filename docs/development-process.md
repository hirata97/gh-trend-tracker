# 開発プロセスガイドライン

このドキュメントは、新規プロジェクト開始時および既存プロジェクト改善時に参照すべき開発プロセスのチェックリストです。

---

## 1. 企画・構想フェーズ（着手前に必須）

### 1.1 目的・価値定義

以下の項目を明文化すること：

- **解決したい課題（Problem Statement）**
  - 現状の何が問題か
  - その問題はどの程度深刻か
  - 解決されない場合の影響

- **想定ユーザー（ペルソナ／利用シーン）**
  - 誰が使うのか（具体的なペルソナ）
  - どのような場面で使うのか
  - 利用頻度・継続性の想定

- **提供価値（Value Proposition）**
  - このプロダクトで何が解決されるか
  - 既存の代替手段との違い
  - ユーザーにとっての具体的なメリット

- **成功条件（KPI／定量指標）**
  - 何をもって成功とするか
  - 測定可能な指標（DAU、継続率、完了率など）
  - 最低限クリアすべき基準

**✔ チェック**: 「なぜ作るか」を文章で説明できる状態になっているか

### 1.2 スコープ定義

以下を明確に区別すること：

- **MVPで「やること／やらないこと」**
  - 最小限の価値提供に必要な機能
  - Nice to haveだが初期リリースでは不要な機能

- **初期リリースに含めない要素**
  - 段階的に追加する機能
  - ユーザーフィードバック後に実装する機能

- **将来的に拡張予定の機能整理**
  - フェーズ2以降で実装予定の機能
  - 拡張性を考慮すべき設計箇所

**✔ チェック**: スコープ肥大を防ぐための明文化ができているか

---

## 2. 要件定義（最重要工程）

### 2.1 機能要件

以下を具体的に定義すること：

- **ユーザーストーリー（Who / What / Why）**
  ```
  誰が（Who）：〇〇なユーザーが
  何を（What）：△△を
  なぜ（Why）：□□するために
  ```

- **機能一覧（CRUD単位で整理）**
  - 各機能の作成（Create）・参照（Read）・更新（Update）・削除（Delete）操作
  - 一覧表示・詳細表示・検索・フィルタリング

- **権限制御**
  - 未ログインユーザーができること
  - ログインユーザーができること
  - 管理者のみができること

- **非同期処理・バッチ有無**
  - バックグラウンド処理が必要な箇所
  - 定期実行が必要な処理
  - キュー処理の必要性

**✔ チェック**: 「画面×操作×結果」で説明できるか

### 2.2 非機能要件

技術選定前に決定すべき項目：

- **パフォーマンス**
  - 応答時間目標（例：API応答 < 200ms）
  - 同時接続数想定
  - データ量増加時の対策

- **可用性**
  - 許容できるダウンタイム
  - 障害時の影響範囲
  - 復旧時間目標（RTO）

- **セキュリティ**
  - 認証・認可方式
  - API制限（レート制限）
  - データ暗号化の必要性
  - GDPR等の法的要件

- **スケーラビリティ**
  - トラフィック増加時の対応方針
  - データ増加時の対応方針

- **運用性**
  - ログ出力レベル・フォーマット
  - 監視項目
  - アラート条件

**✔ チェック**: 後から変更しにくい項目を先に決めているか

### 2.3 制約条件

プロジェクト制約の明文化：

- **開発期間**
  - リリース期限
  - フェーズごとの期限

- **運用コスト上限**
  - インフラコスト
  - サードパーティサービスコスト

- **利用可能な技術・クラウド**
  - 組織の技術スタック制約
  - クラウドプロバイダー制約

- **法的・規約制約**
  - GitHub API利用規約
  - その他API利用規約
  - ライセンス制約

---

## 3. 画面設計（UI/UX）

### 3.1 画面一覧・遷移

以下を整理すること：

- **画面一覧表**
  - 画面名
  - URL
  - 主要機能
  - 権限要件

- **画面遷移図**
  - ユーザーフロー
  - 遷移条件
  - 戻る動作

- **初期表示／空状態（Empty State）**
  - データが0件の場合の表示
  - 初回訪問時の表示

- **エラー表示パターン**
  - バリデーションエラー
  - サーバーエラー
  - ネットワークエラー

**✔ チェック**: 画面数が増えたときに破綻しない構造になっているか

### 3.2 ワイヤーフレーム

設計時の考慮事項：

- **情報の優先順位**
  - 最も重要な情報を最初に表示
  - 視線誘導

- **操作導線**
  - 主要操作への最短経路
  - 迷わないナビゲーション

- **入力項目・必須/任意**
  - 入力フォームの粒度
  - バリデーションルール
  - エラーメッセージ

- **レスポンシブ前提設計**
  - モバイル・タブレット・デスクトップ
  - ブレークポイント

**✔ チェック**: デザインよりも「迷わない構造」を重視しているか

---

## 4. 技術選定（戦略的に）

### 4.1 フロントエンド

選定理由を明文化：

- **フレームワーク選定理由**
  - React / Vue / Svelte / Astro など
  - 選定基準（パフォーマンス、学習コスト、エコシステム）

- **状態管理方針**
  - グローバル状態管理の必要性
  - 状態管理ライブラリ（Redux / Zustand / Pinia など）

- **コンポーネント粒度**
  - Atomic Design採用有無
  - 再利用方針

- **型・Lint・Formatter**
  - TypeScript設定
  - ESLint / Prettier設定

### 4.2 バックエンド

設計方針の明文化：

- **API方式（REST / GraphQL）**
  - 選定理由
  - エンドポイント設計方針

- **認証方式（OAuth / JWT）**
  - セッション管理方式
  - トークン有効期限

- **バッチ・非同期処理方式**
  - ジョブキューの必要性
  - スケジューラー選定

- **レート制限戦略**
  - API制限値
  - 制限超過時の挙動

### 4.3 インフラ

環境選定の理由：

- **実行環境（Serverless / Container）**
  - Cloudflare Workers / AWS Lambda / Cloud Run など
  - 選定理由

- **DB種別（RDB / NoSQL）**
  - PostgreSQL / MySQL / D1 / DynamoDB など
  - データ特性との適合性

- **ストレージ・キャッシュ**
  - 画像・ファイルストレージ
  - キャッシュ戦略（Redis / CDNなど）

- **環境分離（dev / prod）**
  - 開発環境
  - ステージング環境
  - 本番環境

**✔ チェック**: 「なぜその技術か」を説明可能になっているか

---

## 5. データ設計（早期にやるべき）

### 5.1 データモデル

DB設計の明文化：

- **エンティティ定義**
  - テーブル名
  - カラム名・型
  - 制約（NOT NULL / UNIQUE / DEFAULT）

- **主キー・外部キー**
  - 主キー設計（Auto Increment / UUID）
  - 外部キー制約
  - CASCADE設定

- **正規化方針**
  - 第何正規形まで正規化するか
  - 非正規化する箇所とその理由

- **論理削除／履歴管理**
  - 削除方式（物理削除 / 論理削除）
  - 変更履歴の保存要否

### 5.2 API設計

エンドポイント設計：

- **エンドポイント一覧**
  - メソッド（GET / POST / PUT / DELETE）
  - パス
  - 概要

- **リクエスト／レスポンス定義**
  - パラメータ（Path / Query / Body）
  - レスポンス形式（JSON構造）
  - ステータスコード

- **エラーレスポンス統一**
  - エラーコード体系
  - エラーメッセージ形式

- **バージョニング方針**
  - APIバージョン管理方法
  - 後方互換性方針

**✔ チェック**: DB変更が最もコスト高であることを認識しているか

---

## 6. 実装前準備（品質担保）

開発ルールの策定：

- **リポジトリ構成ルール**
  - ディレクトリ構成
  - ファイル命名規則

- **命名規則**
  - 変数・関数・クラス命名
  - コンポーネント命名
  - ファイル命名

- **Commit / PRルール**
  - コミットメッセージフォーマット（Conventional Commits等）
  - PRテンプレート
  - レビュー基準

- **環境構築手順（README）**
  - 開発環境セットアップ手順
  - 依存関係インストール
  - 環境変数設定

---

## 7. テスト設計

### 7.1 テスト方針

テスト範囲の定義：

- **単体テスト範囲**
  - どの層をテストするか
  - カバレッジ目標

- **結合テスト範囲**
  - API結合テスト
  - DB結合テスト

- **E2Eの必要性判断**
  - クリティカルパスのみ
  - 全画面遷移

### 7.2 テスト観点

テストケース設計：

- **正常系**
  - 期待される入力での動作

- **異常系**
  - 不正な入力での動作
  - エラーハンドリング

- **境界値**
  - 最小値・最大値
  - 空文字・null

- **権限別挙動**
  - 未ログイン
  - 一般ユーザー
  - 管理者

**✔ チェック**: 「動く」ではなく「壊れない」を重視しているか

---

## 8. 運用・改善前提設計

運用を見据えた設計：

- **ログ出力設計**
  - ログレベル（DEBUG / INFO / WARN / ERROR）
  - 出力フォーマット
  - センシティブ情報の除外

- **エラー通知**
  - アラート送信先
  - 通知条件
  - エスカレーションフロー

- **メトリクス取得**
  - パフォーマンス指標
  - ビジネス指標
  - インフラ指標

- **利用状況分析（Analytics）**
  - ユーザー行動トラッキング
  - 機能利用率
  - コンバージョン測定

---

## 9. リリース前チェック

本番リリース前の確認事項：

- **初期データ投入**
  - マスターデータ
  - テストデータ削除確認

- **本番環境変数確認**
  - API キー
  - データベース接続情報
  - シークレット管理

- **利用規約・プライバシーポリシー**
  - 法的文書の整備
  - 同意取得フロー

- **バックアップ確認**
  - バックアップ取得確認
  - リストア手順確認

---

## 10. よくある失敗を防ぐチェック

以下の状態を避けること：

- ❌ **要件がコードにしか存在しない**
  - ドキュメント不在
  - 仕様変更の履歴なし

- ❌ **DB設計を後回し**
  - 後から正規化不足が発覚
  - マイグレーションが困難

- ❌ **非機能要件を考えていない**
  - パフォーマンス問題
  - セキュリティ問題
  - スケーラビリティ不足

- ❌ **運用を想定していない**
  - ログが取れない
  - 障害時に原因特定できない
  - デプロイ手順が不明

- ❌ **「あとで直す前提」の設計**
  - 技術的負債の蓄積
  - リファクタリングの困難化

---

## まとめ（実務的優先順位）

### 最優先

1. **目的・価値定義**
   - なぜ作るのか
   - 誰のための何か

2. **要件定義（特に非機能）**
   - パフォーマンス
   - セキュリティ
   - スケーラビリティ

3. **データ設計**
   - DB設計
   - API設計
   - 後から変更しにくい

### 次点

4. **画面設計**
   - ユーザーフロー
   - ワイヤーフレーム

5. **技術選定理由の明文化**
   - なぜその技術を選んだか
   - 代替案との比較

---

## このドキュメントの使い方

- **新規プロジェクト開始時**: 上から順に検討・決定していく
- **既存プロジェクト改善時**: 不足している項目をチェックリストとして使用
- **設計レビュー時**: このドキュメントを基準にレビュー

**重要**: すべてを完璧にする必要はない。プロジェクトの規模・期間・重要度に応じて、必要な項目を選択的に実施すること。
